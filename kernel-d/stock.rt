
defn trash_instantiate (reg, owner, name, template_data, arg) {
    name_with_id â‰¡ gensymbol (â€œtrashâ€)
    return make_leaf (name_with_id, owner, Ï•, â€œâ€, â†ªï¸trash_handler,  Ï•)
}

defn trash_handler (eh, mev) {
    âŒˆ to appease dumped_on_floor checkerâŒ‰
    pass
}
defobj TwoMevents () {
        â€¢ firstmev â‡ Ï•
        â€¢ secondmev â‡ Ï•
}

âŒˆ Deracer_States :: enum { idle, waitingForFirstmev, waitingForSecondmev }âŒ‰
defobj Deracer_Instance_Data () {
        â€¢ state â‡ Ï•
        â€¢ buffer â‡ Ï•
}

defn reclaim_Buffers_from_heap (inst) {
    pass
}

defn deracer_reset_handler (eh) {
    deftemp inst â‡ eh.instance_data
    inst.state â‡ â€œidleâ€
    inst.buffer â‡ #fresh (TwoMevents)
}

defn deracer_instantiate (reg, owner, name, template_data, arg) {
    name_with_id â‰¡ gensymbol (â€œderacerâ€)
    deftemp inst â‡ #fresh (Deracer_Instance_Data)
    inst.state â‡ â€œidleâ€
    inst.buffer â‡ #fresh (TwoMevents)
    eh â‰¡ make_leaf (name_with_id, owner, inst, â€œâ€, â†ªï¸deracer_handler, â†ªï¸deracer_reset_handler)
    return eh
}

defn send_firstmev_then_secondmev (eh, inst) {
    forward (eh, â€œ1â€, inst.buffer.firstmev)
    forward (eh, â€œ2â€, inst.buffer.secondmev)
    reclaim_Buffers_from_heap (inst)
}

defn deracer_handler (eh, mev) {
    deftemp inst â‡ eh.instance_data
    if inst.state = â€œidleâ€ {
        if â€œ1â€ = mev.port {
            inst.buffer.firstmev â‡ mev
            inst.state â‡ â€œwaitingForSecondmevâ€
        } elif â€œ2â€ = mev.port {
            inst.buffer.secondmev â‡ mev
            inst.state â‡ â€œwaitingForFirstmevâ€
        } else {
            runtime_error (#strcons (â€œbad mev.port (case A) for deracer â€, mev.port))
	}
    } elif inst.state = â€œwaitingForFirstmevâ€ {
        if â€œ1â€ = mev.port {
            inst.buffer.firstmev â‡ mev
            send_firstmev_then_secondmev (eh, inst)
            inst.state â‡ â€œidleâ€
        } else {
            runtime_error (#strcons (â€œderacer: waiting for 1 but got [â€, #strcons (mev.port, â€œ] (case B)â€)))
	}
    } elif inst.state = â€œwaitingForSecondmevâ€ {
        if â€œ2â€ = mev.port {
            inst.buffer.secondmev â‡ mev
            send_firstmev_then_secondmev (eh, inst)
            inst.state â‡ â€œidleâ€
        } else {
            runtime_error (#strcons (â€œderacer: waiting for 2 but got [â€, #strcons (mev.port, â€œ] (case C)â€)))
	}
    } else {
        runtime_error (â€œbad state for deracer {eh.state}â€)
    }
}

defn low_level_read_text_file_instantiate (reg, owner, name, template_data, arg) {
    name_with_id â‰¡ gensymbol(â€œLow Level Read Text Fileâ€)
    return make_leaf (name_with_id, owner, Ï•,  â€œâ€, â†ªï¸low_level_read_text_file_handler, Ï•)
}

defn low_level_read_text_file_handler (eh, mev) {
    fname â‰¡ mev.datum.v
    # low_level_read_text_file_handler (eh, mev, fname, â€œâ€, â€œâœ—â€)
}

defn ensure_string_datum_instantiate (reg, owner, name, template_data, arg) {
    name_with_id â‰¡ gensymbol(â€œEnsure String Datumâ€)
    return make_leaf (name_with_id, owner, Ï•, â€œâ€, â†ªï¸ensure_string_datum_handler, Ï•)
}

defn ensure_string_datum_handler (eh, mev) {
    if â€œstringâ€ = mev.datum.kind () {
        forward (eh, â€œâ€, mev)
    } else {
        emev â‰¡ #strcons (â€œ*** ensure: type error (expected a string datum) but got â€, mev.datum)
        send (eh, â€œâœ—â€, emev, mev)
    }
}

defobj Syncfilewrite_Data () {
        â€¢ filename â‡ â€œâ€
}

defn syncfilewrite_reset_handler (eh) {
    eh.instance_data â‡ #fresh (Syncfilewrite_Data)
}

âŒˆ temp copy for bootstrap, sends â€œdoneâ€œ (error during bootstrap if not wired)âŒ‰
defn syncfilewrite_instantiate (reg, owner, name, template_data, arg) {
    name_with_id â‰¡ gensymbol (â€œsyncfilewriteâ€)
    inst â‰¡ #fresh (Syncfilewrite_Data)
    return make_leaf (name_with_id, owner, inst, â€œâ€, â†ªï¸syncfilewrite_handler, â†ªï¸syncfilewrite_reset_handler)
}

defn syncfilewrite_handler (eh, mev) {
    deftemp inst â‡ eh.instance_data
    if â€œfilenameâ€ = mev.port {
        inst.filename â‡ mev.datum.v
    } elif â€œinputâ€ = mev.port {
        contents â‰¡ mev.datum.v
        deftemp f â‡ open (inst.filename, â€œwâ€)
        if f != Ï• {
            f.write (mev.datum.v)
            f.close ()
            send (eh, â€œdoneâ€, new_datum_bang (), mev)
        } else {
            send (eh, â€œâœ—â€, #strcons (â€œopen error on file â€, inst.filename), mev)
	}
    }
}

defobj StringConcat_Instance_Data () {
        â€¢ buffer1 â‡ Ï•
        â€¢ buffer2 â‡ Ï•
}

defn strinconcat_reset_handler (eh) {
    deftemp inst â‡ eh.instance_data
    inst.buffer1 â‡ Ï•
    inst.buffer2 â‡ Ï•
}

defn stringconcat_instantiate (reg, owner, name, template_data, arg) {
    name_with_id â‰¡ gensymbol (â€œstringconcatâ€)
    instp â‰¡ #fresh (StringConcat_Instance_Data)
    return make_leaf (name_with_id, owner, instp, â€œâ€, â†ªï¸stringconcat_handler, â†ªï¸stringconcat_reset_handler)
}

defn stringconcat_handler (eh, mev) {
    deftemp inst â‡ eh.instance_data
    if â€œ1â€ = mev.port{
        inst.buffer1  â‡ clone_string (mev.datum.v)
        maybe_stringconcat (eh, inst, mev)
    } elif â€œ2â€ = mev.port {
        inst.buffer2 â‡ clone_string (mev.datum.v)
        maybe_stringconcat (eh, inst, mev)
    } elif â€œresetâ€ = mev.port {
	inst.buffer1 â‡ Ï•
	inst.buffer2 â‡ Ï•
    } else {
        runtime_error (#strcons (â€œbad mev.port for stringconcat: â€, mev.port))
    }
}

defn maybe_stringconcat (eh, inst, mev) {
    if inst.buffer1 != Ï• and inst.buffer2 != Ï• {
	deftemp concatenated_string â‡ â€œâ€
	if 0 = #len (inst.buffer1) {
	    concatenated_string â‡ inst.buffer2
	} elif 0 = #len (inst.buffer2) {
	    concatenated_string â‡ inst.buffer1
	} else {
	    concatenated_string â‡ inst.buffer1 + inst.buffer2
	}    
	send (eh, â€œâ€, concatenated_string, mev)
	inst.buffer1 â‡ Ï•
	inst.buffer2 â‡ Ï•
    }
}

âŒˆâŒ‰

defn string_constant_instantiate (reg, owner, name, template_data, arg) {
    global projectRoot
    name_with_id â‰¡ gensymbol (â€œstrconstâ€)
    deftemp s â‡ template_data
    if projectRoot != â€œâ€ {
        s â‡ #substitute (â€œ_00_â€, projectRoot, s)
    }
    return make_leaf (name_with_id, owner, s, â€œâ€, â†ªï¸string_constant_handler, Ï•)
}

defn string_constant_handler (eh, mev) {
    s â‰¡ eh.instance_data
    send (eh, â€œâ€, s, mev)
}

defn fakepipename_instantiate (reg, owner, name, template_data, arg) {
    instance_name â‰¡ gensymbol (â€œfakepipeâ€)
    return make_leaf (instance_name, owner, Ï•, â€œâ€, â†ªï¸fakepipename_handler, Ï•)
}

defvar rand â‡ 0

defn fakepipename_handler (eh, mev) {
    global rand
    rand â‡ rand + 1 âŒˆ not very random, but good enough _ 'rand' must be unique within a single runâŒ‰
    send (eh, â€œâ€, #strcons (â€œ/tmp/fakepipeâ€, rand), mev)
}


defobj Switch1star_Instance_Data () {
        â€¢ state â‡ â€œ1â€
}

defn switch1star_reset_handler (eh) {
    deftemp inst â‡ eh.instance_data
    inst â‡ #fresh (Switch1star_Instance_Data)
}

defn switch1star_instantiate (reg, owner, name, template_data, arg) {
    name_with_id â‰¡ gensymbol (â€œswitch1*â€)
    instp â‰¡ #fresh (Switch1star_Instance_Data)
    return make_leaf (name_with_id, owner, instp, â€œâ€, â†ªï¸switch1star_handler, â†ªï¸switch1star_reset_handler)
}

defn switch1star_handler (eh, mev) {
    deftemp inst â‡ eh.instance_data
    whichOutput â‰¡ inst.state
    if â€œâ€ = mev.port {
	if â€œ1â€ = whichOutput {
	    forward (eh, â€œ1â€, mev)
	    inst.state â‡ â€œ*â€
	} elif â€œ*â€ = whichOutput {
	    forward (eh, â€œ*â€, mev)
	} else {
	    send (eh, â€œâœ—â€, â€œinternal error bad state in switch1*â€, mev)
	}
    } elif â€œresetâ€ = mev.port {
	    inst.state â‡ â€œ1â€
    } else {
        send (eh, â€œâœ—â€, â€œinternal error bad mevent for switch1*â€, mev)
    }
}

defobj StringAccumulator () {
        â€¢ s â‡ â€œâ€
}

defn strcatstar_reset_handler (eh) {
    eh.instance_data â‡ #fresh (StringAccumulator)
}

defn strcatstar_instantiate (reg, owner, name, template_data, arg) {
    name_with_id â‰¡ gensymbol (â€œString Concat *â€)
    instp â‰¡ #fresh (StringAccumulator)
    return make_leaf (name_with_id, owner, instp, â€œâ€, â†ªï¸strcatstar_handler, â†ªï¸strcatstar_reset_handler)
}

defn strcatstar_handler (eh, mev) {
    deftemp accum â‡ eh.instance_data
    if â€œâ€ = mev.port {
        accum.s â‡ #strcons (accum.s, mev.datum.v)
    } elif â€œfiniâ€ = mev.port {
        send (eh, â€œâ€, accum.s, mev)
    } else {
        send (eh, â€œâœ—â€, â€œinternal error bad mevent for String Concat *â€, mev)
    }
}

defobj BlockOnErrorState () {
        â€¢ hasError â‡ â€œnoâ€
}

defn blockOnError_reset_handler (eh) {
    eh.instance_data â‡ #fresh (BlockOnErrorState)
}

defn blockOnError_instantiate (reg, owner, name, template_data, arg) {
    name_with_id â‰¡ gensymbol (â€œblockOnErrorâ€)
    instp â‰¡ #fresh (BlockOnErrorState)
    return make_leaf (name_with_id, owner, instp, â€œâ€, â†ªï¸blockOnError_handler, â†ªï¸blockOnError_reset_handler)
}

defn blockOnError_handler (eh, mev) {
    deftemp inst â‡ eh.instance_data
    if â€œâ€ = mev.port {
        if inst.hasError = â€œnoâ€ {
           send (eh, â€œâ€, mev.datum.v, mev)
	}
    } elif  â€œâœ—â€ = mev.port {
        inst.hasError â‡ â€œyesâ€
    } elif  â€œresetâ€ = mev.port {
        inst.hasError â‡ â€œnoâ€
    }
 }

defn stop_instantiate (reg, owner, name, template_data, arg) {
    name_with_id â‰¡ gensymbol (â€œStopâ€)
    inst â‰¡ Ï•
    return make_leaf (name_with_id, owner, inst, â€œâ€, â†ªï¸stop_handler, Ï•)
}

defn stop_handler (eh) {
    deftemp inst â‡ eh.instance_data
    deftemp parent â‡ eh.owner
    deftemp s â‡ #strcons (â€œ   !!! stoppingâ€, parent.name)
    #print_stderr (s)
    #print_nl_stderr ()
    parent.stop (parent)
    forward (eh, â€œâ€, mev)
}

âŒˆ all of the the built_in leaves are listed hereâŒ‰
âŒˆ future: refactor this such that programmers can pick and choose which (lumps of) builtins are used in a specific projectâŒ‰

defn initialize_stock_components (reg) {
    register_component (reg, mkTemplate ( â€œ1then2â€, Ï•, â†ªï¸deracer_instantiate))
    register_component (reg, mkTemplate ( â€œ1â†’2â€, Ï•, â†ªï¸deracer_instantiate))
    register_component (reg, mkTemplate ( â€œtrashâ€, Ï•, â†ªï¸trash_instantiate))
    register_component (reg, mkTemplate ( â€œğŸ—‘ï¸â€, Ï•, â†ªï¸trash_instantiate))
    register_component (reg, mkTemplate ( â€œğŸš«â€, Ï•, â†ªï¸stop_instantiate))
    register_component (reg, mkTemplate ( â€œblockOnErrorâ€, Ï•, â†ªï¸blockOnError_instantiate))


    register_component (reg, mkTemplate ( â€œRead Text Fileâ€, Ï•, â†ªï¸low_level_read_text_file_instantiate))
    register_component (reg, mkTemplate ( â€œEnsure String Datumâ€, Ï•, â†ªï¸ensure_string_datum_instantiate))

    register_component (reg, mkTemplate ( â€œsyncfilewriteâ€, Ï•, â†ªï¸syncfilewrite_instantiate))
    register_component (reg, mkTemplate ( â€œString Concatâ€, Ï•, â†ªï¸stringconcat_instantiate))
    register_component (reg, mkTemplate ( â€œswitch1*â€, Ï•, â†ªï¸switch1star_instantiate))
    register_component (reg, mkTemplate ( â€œString Concat *â€, Ï•, â†ªï¸strcatstar_instantiate))
       âŒˆ for fakepipeâŒ‰
    register_component (reg, mkTemplate ( â€œfakepipenameâ€, Ï•, â†ªï¸fakepipename_instantiate))
}

